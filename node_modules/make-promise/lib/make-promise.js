// Generated by CoffeeScript 1.6.2
(function() {
  var call, makePromise, resolve;

  require("setimmediate");

  module.exports = makePromise = function(fn) {
    var deferreds, error, finalState, resultCB, returnedPromise, state;

    state = void 0;
    finalState = void 0;
    deferreds = [];
    resultCB = function(err, result, forceError) {
      if (forceError == null) {
        forceError = false;
      }
      if (state !== void 0) {
        return;
      }
      state = err || forceError ? [false, err] : [true, result];
      return resolve(returnedPromise, state, function(resolvedState) {
        var deferred, _results;

        finalState = resolvedState;
        _results = [];
        while (deferred = deferreds.shift()) {
          _results.push(call(deferred, finalState));
        }
        return _results;
      });
    };
    try {
      fn(resultCB);
    } catch (_error) {
      error = _error;
      resultCB(error, null, true);
    }
    return returnedPromise = {
      then: function(whenKept, whenBroken) {
        if ((whenKept != null) && typeof whenKept === "object" && (whenKept.onFulfilled || whenKept.onRejected)) {
          whenBroken = whenKept.onRejected;
          whenKept = whenKept.onFulfilled;
        }
        return makePromise(function(cb) {
          var deferred;

          deferred = {
            whenKept: whenKept,
            whenBroken: whenBroken,
            cb: cb
          };
          if (finalState === void 0) {
            return deferreds.push(deferred);
          }
          return setImmediate(function() {
            return call(deferred, finalState);
          });
        });
      }
    };
  };

  resolve = function(returnedPromise, _arg, cb) {
    var error, kept, resolved, thenFn, value, _ref;

    kept = _arg[0], value = _arg[1];
    if (value === returnedPromise && returnedPromise !== void 0) {
      return cb([false, new TypeError("Cannot resolve with returned promise.")]);
    }
    if (!kept) {
      return cb([false, value]);
    }
    if (!value) {
      return cb([true, value]);
    }
    if ((_ref = typeof value) !== "object" && _ref !== "function") {
      return cb([true, value]);
    }
    try {
      thenFn = value.then;
    } catch (_error) {
      error = _error;
      return cb([false, error]);
    }
    if (typeof thenFn !== "function") {
      return cb([true, value]);
    }
    resolved = false;
    try {
      return thenFn.call(value, function(result) {
        if (resolved) {
          return;
        }
        resolved = true;
        return resolve(returnedPromise, [true, result], cb);
      }, function(err) {
        if (!resolved) {
          return cb([false, err]);
        }
      });
    } catch (_error) {
      error = _error;
      if (!resolved) {
        return cb([false, error]);
      }
    }
  };

  call = function(deferred, _arg) {
    var cb, err, kept, value;

    kept = _arg[0], value = _arg[1];
    cb = kept ? deferred.whenKept : deferred.whenBroken;
    if (typeof cb === "function") {
      try {
        return deferred.cb(null, cb(value));
      } catch (_error) {
        err = _error;
        return deferred.cb(err, null, true);
      }
    }
    if (kept) {
      return deferred.cb(null, value);
    } else {
      return deferred.cb(value, null, true);
    }
  };

}).call(this);

/*
//@ sourceMappingURL=make-promise.map
*/
